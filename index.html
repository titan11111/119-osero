<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Othello - Sound & Strategy</title>
    <style>
        :root {
            --ui-bg: rgba(0, 0, 0, 0.85);
            --accent-easy: #4CAF50;
            --accent-normal: #FF9800;
            --accent-hard: #f44336;
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #121212;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none; -webkit-touch-callout: none;
            position: fixed; width: 100%; height: 100%;
        }

        /* スタート画面 */
        #start-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #start-screen h2 {
            color: white;
            font-size: 32px;
            margin-bottom: 40px;
            letter-spacing: 5px;
        }

        .level-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 250px;
        }

        .level-btn {
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .level-btn:active { transform: scale(0.95); }
        .btn-easy { background: var(--accent-easy); }
        .btn-normal { background: var(--accent-normal); }
        .btn-hard { background: var(--accent-hard); }

        /* ゲームUI */
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom) 0;
            box-sizing: border-box; z-index: 10;
        }

        #header {
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
            color: white; padding: 15px; text-align: center; pointer-events: auto;
        }

        h1 { margin: 0; font-size: 18px; letter-spacing: 2px; }
        #difficulty-label { font-size: 12px; color: #aaa; margin-top: 4px; }

        #score-board { display: flex; justify-content: center; gap: 10px; margin-top: 10px; }
        .score-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 15px; border-radius: 15px;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; gap: 8px; font-size: 14px;
        }

        .indicator { width: 12px; height: 12px; border-radius: 50%; }
        .indicator.black { background-color: #000; border: 1px solid #555; }
        .indicator.white { background-color: #fff; }

        #turn-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: white; background-color: var(--ui-bg);
            padding: 12px 30px; border-radius: 30px;
            opacity: 0; transition: opacity 0.4s; pointer-events: none;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6); text-align: center;
            z-index: 20;
        }

        #footer {
            padding: 20px; text-align: center; pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0));
        }

        .restart-btn {
            background: #444; color: white; border: none;
            padding: 10px 25px; font-size: 14px; border-radius: 20px;
            cursor: pointer; opacity: 0.8;
        }

        .tutorial { font-size: 10px; color: #888; margin-top: 10px; }

        @media (min-width: 768px) {
            h1 { font-size: 24px; }
            .score-box { font-size: 18px; padding: 10px 30px; }
            #start-screen h2 { font-size: 48px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="start-screen">
        <h2>OTHELLO 3D</h2>
        <div class="level-buttons">
            <button class="level-btn btn-easy" onclick="startGame('EASY')">EASY</button>
            <button class="level-btn btn-normal" onclick="startGame('NORMAL')">NORMAL</button>
            <button class="level-btn btn-hard" onclick="startGame('HARD')">HARD</button>
        </div>
    </div>

    <div id="ui-container">
        <div id="header">
            <h1>OTHELLO 3D</h1>
            <div id="difficulty-label">LEVEL: -</div>
            <div id="score-board">
                <div class="score-box" id="score-black-box">
                    <span class="indicator black"></span>
                    YOU: <span id="score-black">2</span>
                </div>
                <div class="score-box" id="score-white-box">
                    <span class="indicator white"></span>
                    CPU: <span id="score-white">2</span>
                </div>
            </div>
        </div>

        <div id="turn-message">あなたの番です</div>

        <div id="footer">
            <button class="restart-btn" onclick="showStartScreen()">タイトルへ戻る</button>
            <div class="tutorial">ドラッグでカメラ回転 / 盤面をタップで石を置く</div>
        </div>
    </div>

    <script>
        // --- 設定値 ---
        const BOARD_SIZE = 8;
        const CELL_SIZE = 10;
        const BOARD_WIDTH = BOARD_SIZE * CELL_SIZE;
        const EMPTY = 0, BLACK = 1, WHITE = 2;
        const ZOOM_FACTOR = 0.9; 

        let boardState = [];
        let currentPlayer = BLACK;
        let gameActive = false;
        let gameLevel = 'NORMAL';
        
        let scene, camera, renderer, raycaster, mouse;
        let pieces = [];
        let tileMeshes = [];
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { theta: 0, phi: Math.PI / 3 }; 
        let cameraRadius = 100;

        // --- 音声システム (Web Audio API) ---
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playStoneSound() {
            if (!audioCtx) return;
            initAudio(); // 念のため再開

            const now = audioCtx.currentTime;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            // 「カチッ」という音のシミュレーション
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(800, now);
            oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);

            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start(now);
            oscillator.stop(now + 0.1);

            // わずかなノイズを混ぜて石の質感を出す
            const noiseGain = audioCtx.createGain();
            const bufferSize = audioCtx.sampleRate * 0.05;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            noiseGain.gain.setValueAtTime(0.05, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

            noiseSource.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noiseSource.start(now);
        }

        window.onload = () => {
            init3D();
            animate();
        };

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(20, 100, 50);
            light.castShadow = true;
            scene.add(light);

            createBoard();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            onWindowResize();
            window.addEventListener('resize', onWindowResize, false);
            
            const options = { passive: false };
            document.addEventListener('mousedown', e => { 
                initAudio(); // ユーザー操作でオーディオ有効化
                isDragging = true; 
                previousMousePosition = { x: e.clientX, y: e.clientY }; 
            }, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', () => isDragging = false, false);
            document.addEventListener('wheel', e => { 
                e.preventDefault(); 
                cameraRadius = Math.max(50, Math.min(220, cameraRadius + e.deltaY * 0.2)); 
                updateCamera(); 
            }, options);
            document.addEventListener('click', onClick, false);

            document.addEventListener('touchstart', e => { 
                initAudio(); // ユーザー操作でオーディオ有効化
                if(e.touches.length === 1) { 
                    isDragging = true; 
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
                } 
            }, options);
            document.addEventListener('touchmove', onTouchMove, options);
            document.addEventListener('touchend', () => isDragging = false, false);
        }

        function createBoard() {
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(BOARD_WIDTH + 6, 2, BOARD_WIDTH + 6),
                new THREE.MeshStandardMaterial({ color: 0x212121, roughness: 0.8 })
            );
            frame.position.y = -1.5;
            scene.add(frame);
            const m1 = new THREE.MeshStandardMaterial({ color: 0x1b5e20 });
            const m2 = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
            for (let z = 0; z < BOARD_SIZE; z++) {
                pieces[z] = [];
                for (let x = 0; x < BOARD_SIZE; x++) {
                    const tile = new THREE.Mesh(new THREE.BoxGeometry(CELL_SIZE - 0.5, 1, CELL_SIZE - 0.5), (x + z) % 2 === 0 ? m1 : m2);
                    tile.position.set((x - 3.5) * CELL_SIZE, -0.5, (z - 3.5) * CELL_SIZE);
                    tile.userData = { gridX: x, gridZ: z };
                    scene.add(tile);
                    tileMeshes.push(tile);
                }
            }
        }

        function createPiece(color, x, z) {
            const geometry = new THREE.CylinderGeometry(CELL_SIZE * 0.4, CELL_SIZE * 0.4, 2, 32);
            const mats = [
                new THREE.MeshStandardMaterial({ color: 0x444444 }), 
                new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 }), 
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 })
            ];
            const p = new THREE.Mesh(geometry, mats);
            p.position.set((x - 3.5) * CELL_SIZE, 1, (z - 3.5) * CELL_SIZE);
            if (color === WHITE) p.rotation.x = Math.PI;
            p.userData = { targetRotationX: p.rotation.x };
            scene.add(p);
            pieces[z][x] = p;
        }

        function onWindowResize() {
            const w = window.innerWidth, h = window.innerHeight, aspect = w / h;
            camera.aspect = aspect; camera.updateProjectionMatrix(); renderer.setSize(w, h);
            const baseSize = BOARD_WIDTH * ZOOM_FACTOR;
            cameraRadius = aspect < 1 ? (baseSize / Math.tan((camera.fov * Math.PI / 180) / 2)) / aspect : (baseSize / Math.tan((camera.fov * Math.PI / 180) / 2));
            updateCamera();
        }

        function updateCamera() {
            camera.position.set(
                cameraRadius * Math.sin(cameraAngle.phi) * Math.sin(cameraAngle.theta),
                cameraRadius * Math.cos(cameraAngle.phi),
                cameraRadius * Math.sin(cameraAngle.phi) * Math.cos(cameraAngle.theta)
            );
            camera.lookAt(0, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            for (let z = 0; z < 8; z++) {
                for (let x = 0; x < 8; x++) {
                    const p = pieces[z][x];
                    if (p) {
                        const d = p.userData.targetRotationX - p.rotation.x;
                        if (Math.abs(d) > 0.01) {
                            p.rotation.x += d * 0.1;
                            p.position.y = 1 + Math.sin(Math.abs(d)) * 8;
                        } else {
                            p.rotation.x = p.userData.targetRotationX;
                            p.position.y = 1;
                        }
                    }
                }
            }
            renderer.render(scene, camera);
        }

        // --- Game Logic ---
        function showStartScreen() {
            gameActive = false;
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('start-screen').style.opacity = '1';
        }

        function startGame(level) {
            initAudio(); // ゲーム開始時に音声コンテキストを有効化
            gameLevel = level;
            document.getElementById('difficulty-label').textContent = `LEVEL: ${level}`;
            document.getElementById('start-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('start-screen').style.display = 'none';
                initGame();
            }, 500);
        }

        function initGame() {
            boardState = Array(8).fill(null).map(() => Array(8).fill(EMPTY));
            pieces.forEach((row, z) => row.forEach((p, x) => { if(p){ scene.remove(p); pieces[z][x]=null; }}));
            place(3, 3, WHITE); place(4, 4, WHITE); place(3, 4, BLACK); place(4, 3, BLACK);
            currentPlayer = BLACK; gameActive = true; updateUI(); showMsg("あなたの番です", 2000);
        }

        function place(x, z, c) { 
            boardState[z][x] = c; 
            createPiece(c, x, z); 
        }
        
        function canPlace(gx, gz, p) {
            if (boardState[gz][gx] !== EMPTY) return false;
            const opp = p === BLACK ? WHITE : BLACK;
            const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            for (let [dx, dz] of dirs) {
                let x = gx + dx, z = gz + dz, ok = false;
                while (x >= 0 && x < 8 && z >= 0 && z < 8) {
                    if (boardState[z][x] === opp) ok = true;
                    else if (boardState[z][x] === p) { if (ok) return true; break; }
                    else break;
                    x += dx; z += dz;
                }
            }
            return false;
        }

        function getFlipCount(gx, gz, p) {
            const opp = p === BLACK ? WHITE : BLACK;
            let total = 0;
            [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dx, dz]) => {
                let x = gx + dx, z = gz + dz, count = 0;
                while (x >= 0 && x < 8 && z >= 0 && z < 8) {
                    if (boardState[z][x] === opp) count++;
                    else if (boardState[z][x] === p) { total += count; break; }
                    else break;
                    x += dx; z += dz;
                }
            });
            return total;
        }

        function move(gx, gz, p) {
            if (!gameActive) return;
            
            // 石を置いた音
            playStoneSound();

            boardState[gz][gx] = p; 
            createPiece(p, gx, gz);
            const opp = p === BLACK ? WHITE : BLACK;
            [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dx, dz]) => {
                let x = gx + dx, z = gz + dz, flips = [];
                while (x >= 0 && x < 8 && z >= 0 && z < 8) {
                    if (boardState[z][x] === opp) flips.push({x, z});
                    else if (boardState[z][x] === p) {
                        flips.forEach(f => { boardState[f.z][f.x] = p; pieces[f.z][f.x].userData.targetRotationX += Math.PI; });
                        break;
                    } else break;
                    x += dx; z += dz;
                }
            });
            currentPlayer = opp; updateUI();
            if (!hasMove(currentPlayer)) {
                currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
                if (!hasMove(currentPlayer)) { gameActive = false; declare(); return; }
                showMsg("パス！", 2000);
            }
            if (currentPlayer === WHITE) setTimeout(cpu, 800);
        }

        function hasMove(p) { for(let z=0; z<8; z++) for(let x=0; x<8; x++) if(canPlace(x, z, p)) return true; return false; }

        function cpu() {
            let list = [];
            for(let z=0; z<8; z++) for(let x=0; x<8; x++) if(canPlace(x, z, WHITE)) list.push({x, z});
            if(list.length === 0) return;

            let target;
            if (gameLevel === 'EASY') {
                target = list[Math.floor(Math.random() * list.length)];
            } else if (gameLevel === 'NORMAL') {
                const corners = list.filter(m => (m.x===0||m.x===7)&&(m.z===0||m.z===7));
                if (corners.length > 0) {
                    target = corners[Math.floor(Math.random() * corners.length)];
                } else {
                    list.sort((a, b) => getFlipCount(b.x, b.z, WHITE) - getFlipCount(a.x, a.z, WHITE));
                    target = list[0];
                }
            } else {
                let scoredMoves = list.map(m => {
                    let s = getFlipCount(m.x, m.z, WHITE);
                    if ((m.x===0||m.x===7)&&(m.z===0||m.z===7)) s += 100;
                    if ((m.x===1||m.x===6)&&(m.z===1||m.z===6)) s -= 50;
                    if (((m.x===0||m.x===7)&&(m.z===1||m.z===6)) || ((m.x===1||m.x===6)&&(m.z===0||m.z===7))) s -= 30;
                    if (m.x===0||m.x===7||m.z===0||m.z===7) s += 10;
                    return { ...m, score: s };
                });
                scoredMoves.sort((a, b) => b.score - a.score);
                target = scoredMoves[0];
            }
            move(target.x, target.z, WHITE);
        }

        function updateUI() {
            let b=0, w=0; boardState.forEach(r => r.forEach(c => { if(c===BLACK) b++; if(c===WHITE) w++; }));
            document.getElementById('score-black').textContent = b; document.getElementById('score-white').textContent = w;
            document.getElementById('score-black-box').style.background = currentPlayer === BLACK ? "rgba(255,255,255,0.3)" : "rgba(255,255,255,0.1)";
            document.getElementById('score-white-box').style.background = currentPlayer === WHITE ? "rgba(255,255,255,0.3)" : "rgba(255,255,255,0.1)";
        }

        function showMsg(t, d) { const el = document.getElementById('turn-message'); el.textContent = t; el.style.opacity = 1; if(d>0) setTimeout(()=>el.style.opacity=0, d); }
        
        function declare() {
            let b=0, w=0; boardState.forEach(r => r.forEach(c => { if(c===BLACK) b++; if(c===WHITE) w++; }));
            let result = b > w ? "YOUR WIN!" : b < w ? "CPU WIN..." : "DRAW";
            showMsg(`GAME OVER\n${result}`, 0);
        }

        function onMouseMove(e) {
            if (isDragging) {
                cameraAngle.theta -= (e.clientX - previousMousePosition.x) * 0.005;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, cameraAngle.phi - (e.clientY - previousMousePosition.y) * 0.005));
                updateCamera();
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        }
        function onTouchMove(e) {
            if (isDragging && e.touches.length === 1) {
                e.preventDefault();
                cameraAngle.theta -= (e.touches[0].clientX - previousMousePosition.x) * 0.006;
                cameraAngle.phi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, cameraAngle.phi - (e.touches[0].clientY - previousMousePosition.y) * 0.006));
                updateCamera();
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }
        function onClick(e) {
            if (e.target.closest('button') || currentPlayer !== BLACK || !gameActive) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(tileMeshes);
            if (hits.length > 0) {
                const { gridX, gridZ } = hits[0].object.userData;
                if (canPlace(gridX, gridZ, BLACK)) move(gridX, gridZ, BLACK);
            }
        }
    </script>
</body>
</html>
